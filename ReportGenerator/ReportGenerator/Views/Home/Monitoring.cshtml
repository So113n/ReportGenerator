@{
    ViewData["Title"] = "Мониторинг";
}

<div class="container mt-4">
    <h1 class="mb-4">Мониторинг производительности</h1>

    <!-- ГРАФИКИ (2 блока сверху) -->
    <div class="row mb-4">
        <div class="col-lg-6 mb-3">
            <div class="card h-100">
                <div class="card-header">Нагрузка на процессор</div>
                <div class="card-body" style="height: 280px;">
                    <canvas id="cpuChart"></canvas>
                </div>
            </div>
        </div>

        <div class="col-lg-6 mb-3">
            <div class="card h-100">
                <div class="card-header">Оперативная память</div>
                <div class="card-body" style="height: 280px;">
                    <canvas id="memChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- ТВОИ ТЕКУЩИЕ БЛОКИ (оставляем) -->
    <div class="row">
        <div class="col-md-6">
            <div class="card mb-4">
                <div class="card-header">Текущие метрики</div>
                <div class="card-body">
                    <p><strong>CPU:</strong> <span id="cpuUsage">0%</span></p>
                    <p><strong>Память:</strong> <span id="memoryUsage">0 MB</span></p>
                    <p><strong>Запросов:</strong> <span id="requestCount">0</span></p>
                    <p><strong>Исключения:</strong> <span id="exceptionCount">0</span></p>
                </div>
            </div>
        </div>

        <div class="col-md-6">
            <div class="card mb-4">
                <div class="card-header">Активные уведомления</div>
                <div class="card-body">
                    <div id="alertsContainer">
                        <p class="text-success">Нет активных уведомлений</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <!-- Chart.js (без установки npm, просто CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <script>
        // Сколько точек держим на графиках (например, последние 60 точек)
        const MAX_POINTS = 60;

        // Общие массивы для оси X и данных
        const labels = [];
        const cpuSeries = [];
        const memSeries = [];

        let cpuChart = null;
        let memChart = null;

        function formatTimeLabel(dateObj) {
            // Локальное время браузера (исправляет UTC-смещение на клиенте)
            return dateObj.toLocaleTimeString('ru-RU', { hour12: false });
        }

        function bytesToMb(bytes) {
            return bytes / 1024 / 1024;
        }

        function trimToMax() {
            while (labels.length > MAX_POINTS) labels.shift();
            while (cpuSeries.length > MAX_POINTS) cpuSeries.shift();
            while (memSeries.length > MAX_POINTS) memSeries.shift();
        }

        function createCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            const memCtx = document.getElementById('memChart').getContext('2d');

            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CPU, %',
                        data: cpuSeries,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.25
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            min: 0,
                            max: 100,
                            ticks: {
                                callback: (v) => v + '%'
                            },
                            grid: { borderDash: [4, 4] }
                        },
                        x: {
                            grid: { borderDash: [4, 4] },
                            ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
                        }
                    }
                }
            });

            memChart = new Chart(memCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'RAM, MB',
                        data: memSeries,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.25,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            ticks: {
                                callback: (v) => v + ' MB'
                            },
                            grid: { borderDash: [4, 4] }
                        },
                        x: {
                            grid: { borderDash: [4, 4] },
                            ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
                        }
                    }
                }
            });
        }

        function appendPoint(timestampIso, cpuPercent, memoryBytes) {
            const t = timestampIso ? new Date(timestampIso) : new Date();
            labels.push(formatTimeLabel(t));

            cpuSeries.push(Number(cpuPercent));
            memSeries.push(Number(bytesToMb(memoryBytes)));

            trimToMax();

            cpuChart.update('none');
            memChart.update('none');
        }

        async function loadHistory() {
            // Берём историю, чтобы графики не были пустыми при открытии
            const response = await fetch('/api/monitoring/metrics');
            if (!response.ok) return;

            const history = await response.json();
            if (!Array.isArray(history) || history.length === 0) return;

            const last = history.slice(-MAX_POINTS);

            for (const m of last) {
                // timestamp у тебя UTC на сервере; new Date(...) покажет локально в браузере
                appendPoint(m.timestamp, m.cpuUsagePercent, m.memoryUsageBytes);
            }
        }

        async function loadMetrics() {
            try {
                const response = await fetch('/api/monitoring/metrics/current');
                const metrics = await response.json();

                // Текстовые метрики (как у тебя было)
                document.getElementById('cpuUsage').textContent = metrics.cpuUsagePercent.toFixed(2) + '%';
                document.getElementById('memoryUsage').textContent = (metrics.memoryUsageBytes / 1024 / 1024).toFixed(2) + ' MB';
                document.getElementById('requestCount').textContent = metrics.requestsCount;
                document.getElementById('exceptionCount').textContent = metrics.exceptionsCount;

                updateAlerts(metrics.alerts);

                // Графики: добавляем новую точку
                appendPoint(metrics.timestamp, metrics.cpuUsagePercent, metrics.memoryUsageBytes);
            } catch (error) {
                console.error('Ошибка загрузки метрик:', error);
            }
        }

        function updateAlerts(alerts) {
            const container = document.getElementById('alertsContainer');

            if (!alerts || alerts.length === 0) {
                container.innerHTML = '<p class="text-success">Нет активных уведомлений</p>';
                return;
            }

            container.innerHTML = alerts.map(alert => `
                <div class="alert alert-warning">
                    <strong>${alert.type}:</strong> ${alert.message}
                </div>
            `).join('');
        }

        document.addEventListener('DOMContentLoaded', async () => {
            createCharts();
            await loadHistory();  // стартовая подгрузка истории
            await loadMetrics();  // сразу обновить текущие значения
            setInterval(loadMetrics, 1000); // дальше обновление “в реальном времени”
        });
    </script>
}
